---
title: "Tidyverse et rlang"
author: "Atelier R avancé"
date: "26/08/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

# Eléments généraux

Les éléments de l'introduction proviennent du site d'aide de [dplyr](https://cran.r-project.org/web/packages/dplyr/vignettes/programming.html). 

L'évaluation tidy est un type d'évaluation utilisée dans tout le tidyverse. Les verbes dplyr utilise d'une manière ou d'une autre l'évaluation tidy. Il en existe essentiellement 2 formes :

- `arrange()`, `count()`, `filter()`, `group_by()`, `mutate()`, and `summarise()` : ces verbes utilisent le masquage de données (data masking). De cette facon, les valriables dans des données peuvent être utilisées comme si elles étaient dans l'environnement. Plus besoin d'écrire 'df$var' mais simplement 'var' dans le verbe dplyr.

- `across()`, `relocate()`, `rename()`, `select()`, and `pull()` : ces verbes utilisent la sélection tidy et permettent de choisir facilement des variables en se basant sur leur position, leur nom ou leur type.  (e.g. `starts_with("x")` or `is.numeric()`).

Ces verbes rendent l'exploration de données rapide et fluide mais ils peuvent poser des problèmes dans le cas où ils sont utilisés dans des boucles ou des fonctions.

# Examples d'utilisation de rlang

## Tidy evaluation à l'aide de `{{` et `.data`. 

L'utilisation de fonctions du tidyverse dans des fonctions personnelles peut parfois poser problème

```{r, message=FALSE}
library(tidyverse)
data(penguins, package = "palmerpenguins")
```

```{r}
## This works
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) + 
  geom_point() + 
  ggtitle("Variable = species")
```

```{r, error = TRUE}
## This doesn't
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = var)) + 
    geom_point() + 
    ggtitle(glue::glue("{var}"))
}
my_plot(species)
```

Le problème vient de l'évaluatino de `var` dans l'appel à `my_plot()`: R cherche `species` dans l'environnement parent de la fonction plutôt que dans le contexte du data.frame `penguins`. 

On peut remédier au problème à l'aide de l'opérateur `{{` qui permet de remplacer `var` par `species` en tant que symbole.  


```{r}
## This works
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = {{ var }})) + 
    geom_point()
}
my_plot(species)
```

À noter qu'on obtient l'équivalent de `{{ var }}` en combinant `enquo` (conversion en "quosure" = expression + environnement) et `!!` (évaluation sauce "tidy") :

```{r, results='hide'}
## This works
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = !!enquo(var))) + 
    geom_point()
}
my_plot(species)
```

Si on veut afficher le titre de façon programmatique, il faut `ensym()` (conversion en symbole) pour qu'il soit reconnu comme une chaîne de caractères

```{r}
## This works
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = {{ var }})) + 
    geom_point() + 
    ggtitle(glue::glue("Variable = {ensym(var)}"))
}
my_plot(species)
```



Attention, dans cet example, l'argument de `my_plot()` est un `symbol`. On ne peut donc pas itérer sur les colonnes catégorielles de `penguins` stockées dans un vecteur de `"character"`: ces dernières ne sont pas interprétées correctement...

```{r}
cat_vars <- names(penguins)[map_lgl(penguins, is.factor)] ## [1] "species" "island"  "sex" 
map(cat_vars, my_plot) %>% cowplot::plot_grid(plotlist = .)
```

Pour que `my_plot()` accepte des chaînes de caractères, il faut utiliser le pronom spécial `.data` pour préciser que la variable doit être cherchée dans le tableau `penguins`. 

```{r}
## This works
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = .data[[var]] )) + 
    geom_point() + 
    ggtitle(glue::glue("Variable = {var}"))
}
my_plot("species")
```


```{r}
map(cat_vars, my_plot) %>% cowplot::plot_grid(plotlist = .)
```

## Comparaisons entre `.env` et `.data`. 

Essayons de ne représenter qu'une partie du jeu de données, par exemple les manchots Adelie

```{r}
ggplot(penguins %>% filter(species == "Adelie"), 
       aes(x = bill_length_mm, y = bill_depth_mm, color = island)) + 
    geom_point() + 
    ggtitle("Penguins of species Adelie, colored by island")
```

On peut essayer de fonctionaliser ce graphique

```{r}
## This seems to works
my_plot <- function(species) {
  ggplot(penguins %>% filter(species == species), 
         aes(x = bill_length_mm, y = bill_depth_mm, color = island )) + 
    geom_point() + 
    ggtitle(glue::glue("Penguins of species {species}, colored by island"))
}
```

Mais ça ne marche pas...
```{r}
my_plot("Adelie")
```

Il faut être rigoureux et distinguer la _data variable_ `species` de la valeur de l'_argument_ `species`. On peut renommer l'argument en `.species` mais c'est désagréable. Une solution élégante consiste à utiliser le pronom `.env` pour distinguer les deux symboles. 

```{r}
## This works
my_plot <- function(species) {
  ggplot(penguins %>% filter(species == .env$species), 
         aes(x = bill_length_mm, y = bill_depth_mm, color = island )) + 
    geom_point() + 
    ggtitle(glue::glue("Penguins of species {species}, colored by island"))
}
```

```{r}
my_plot("Adelie")
```

On peut alors itérer sur les espèces de penguins
```{r}
unique(penguins$species) %>% map(my_plot) %>% cowplot::plot_grid(plotlist = .)
```

On peut évidemment combiner la sélection d'une espèce avec le coloriage par une variable catégorielle. 

```{r}
my_plot <- function(species, color) {
  ggplot(penguins %>% filter(species == .env$species), 
         aes(x = bill_length_mm, y = bill_depth_mm, color = .data[[color]])) + 
    geom_point() + 
    ggtitle(glue::glue("Penguins of species {species}, colored by {color}"))
}
my_plot("Adelie", "sex")
```

## Utilisation de `:=`
