---
title: "Tidyverse et rlang"
author: "Atelier R avancé"
date: "26/08/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

# Eléments généraux

Les éléments de l'introduction proviennent du site d'aide de [dplyr](https://cran.r-project.org/web/packages/dplyr/vignettes/programming.html). 

L'évaluation tidy est un type d'évaluation utilisée dans tout le tidyverse. Les verbes dplyr utilise d'une manière ou d'une autre l'évaluation tidy. Il en existe essentiellement 2 formes :

- `arrange()`, `count()`, `filter()`, `group_by()`, `mutate()`, and `summarise()` : ces verbes utilisent le masquage de données (data masking). De cette facon, les valriables dans des données peuvent être utilisées comme si elles étaient dans l'environnement. Plus besoin d'écrire 'df$var' mais simplement 'var' dans le verbe dplyr.

- `across()`, `relocate()`, `rename()`, `select()`, and `pull()` : ces verbes utilisent la sélection tidy et permettent de choisir facilement des variables en se basant sur leur position, leur nom ou leur type.  (e.g. `starts_with("x")` or `is.numeric()`).

Ces verbes rendent l'exploration de données rapide et fluide mais ils peuvent poser des problèmes dans le cas où ils sont utilisés dans des boucles ou des fonctions.

Une fonction qui utilise le data masking peut notamment poser problème lorsqu'elle appelle le nom d'une variable dans un tableau à partir d'une variable de l'environnement sans taper explicitement la variable du tableau (on peut utiliser le double crochet `{{}}` ou le `.data[[]]` si la variable est une chaine de charactère). De facon général, il faut différencier explicitement les variables selon qu'elles sont dans le dataframe ou dans l'environnment.


La séléction tidy est un outil complémentaire qui facilite le travaille sur les colonnes d'un jeu de données.

La suite du document donnent quelques exemple d'utilisation de rlang.

# Examples d'utilisation de rlang

## Tidy evaluation à l'aide de `{{` et `.data`. 

L'utilisation de fonctions du tidyverse dans des fonctions personnelles peut parfois poser problème

```{r, message=FALSE}
library(tidyverse)
data(penguins, package = "palmerpenguins")
```

```{r}
## This works
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) + 
  geom_point() + 
  ggtitle("Variable = species")
```

```{r, error = TRUE}
## This doesn't
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = var)) + 
    geom_point() + 
    ggtitle(glue::glue("{var}"))
}
my_plot(species)
```

Le problème vient de l'évaluatino de `var` dans l'appel à `my_plot()`: R cherche `species` dans l'environnement parent de la fonction plutôt que dans le contexte du data.frame `penguins`. 

On peut remédier au problème à l'aide de l'opérateur `{{` qui permet de remplacer `var` par `species` en tant que symbole.  


```{r}
## This works
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = {{ var }})) + 
    geom_point()
}
my_plot(species)
```

À noter qu'on obtient l'équivalent de `{{ var }}` en combinant `enquo` (conversion en "quosure" = expression + environnement) et `!!` (évaluation sauce "tidy") :

```{r, results='hide'}
## This works
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = !!enquo(var))) + 
    geom_point()
}
my_plot(species)
```

Si on veut afficher le titre de façon programmatique, il faut `ensym()` (conversion en symbole) pour qu'il soit reconnu comme une chaîne de caractères

```{r}
## This works
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = {{ var }})) + 
    geom_point() + 
    ggtitle(glue::glue("Variable = {ensym(var)}"))
}
my_plot(species)
```



Attention, dans cet example, l'argument de `my_plot()` est un `symbol`. On ne peut donc pas itérer sur les colonnes catégorielles de `penguins` stockées dans un vecteur de `"character"`: ces dernières ne sont pas interprétées correctement...

```{r}
cat_vars <- names(penguins)[map_lgl(penguins, is.factor)] ## [1] "species" "island"  "sex" 
map(cat_vars, my_plot) %>% cowplot::plot_grid(plotlist = .)
```

Pour que `my_plot()` accepte des chaînes de caractères, il faut utiliser le pronom spécial `.data` pour préciser que la variable doit être cherchée dans le tableau `penguins`. 

```{r}
## This works
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = .data[[var]] )) + 
    geom_point() + 
    ggtitle(glue::glue("Variable = {var}"))
}
my_plot("species")
```


```{r}
map(cat_vars, my_plot) %>% cowplot::plot_grid(plotlist = .)
```

## Comparaisons entre `.env` et `.data`. 

Essayons de ne représenter qu'une partie du jeu de données, par exemple les manchots Adelie

```{r}
ggplot(penguins %>% filter(species == "Adelie"), 
       aes(x = bill_length_mm, y = bill_depth_mm, color = island)) + 
    geom_point() + 
    ggtitle("Penguins of species Adelie, colored by island")
```

On peut essayer de fonctionaliser ce graphique

```{r}
## This seems to works
my_plot <- function(species) {
  ggplot(penguins %>% filter(species == species), 
         aes(x = bill_length_mm, y = bill_depth_mm, color = island )) + 
    geom_point() + 
    ggtitle(glue::glue("Penguins of species {species}, colored by island"))
}
```

Mais ça ne marche pas...
```{r}
my_plot("Adelie")
```

Il faut être rigoureux et distinguer la _data variable_ `species` de la valeur de l'_argument_ `species`. On peut renommer l'argument en `.species` mais c'est désagréable. Une solution élégante consiste à utiliser le pronom `.env` pour distinguer les deux symboles. 

```{r}
## This works
my_plot <- function(species) {
  ggplot(penguins %>% filter(species == .env$species), 
         aes(x = bill_length_mm, y = bill_depth_mm, color = island )) + 
    geom_point() + 
    ggtitle(glue::glue("Penguins of species {species}, colored by island"))
}
```

```{r}
my_plot("Adelie")
```

On peut alors itérer sur les espèces de penguins
```{r}
unique(penguins$species) %>% map(my_plot) %>% cowplot::plot_grid(plotlist = .)
```

On peut évidemment combiner la sélection d'une espèce avec le coloriage par une variable catégorielle. 

```{r}
my_plot <- function(species, color) {
  ggplot(penguins %>% filter(species == .env$species), 
         aes(x = bill_length_mm, y = bill_depth_mm, color = .data[[color]])) + 
    geom_point() + 
    ggtitle(glue::glue("Penguins of species {species}, colored by {color}"))
}
my_plot("Adelie", "sex")
```

## Utilisation de `:=`
