---
title: "Tidyverse et rlang"
author: "Atelier R avancé"
date: "26/08/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

# Eléments généraux

Les éléments de l'introduction proviennent du site d'aide de [dplyr](https://cran.r-project.org/web/packages/dplyr/vignettes/programming.html). 

L'évaluation tidy est un type d'évaluation utilisée dans tout le tidyverse. Les verbes dplyr utilise d'une manière ou d'une autre l'évaluation tidy. Il en existe essentiellement 2 formes :

- `arrange()`, `count()`, `filter()`, `group_by()`, `mutate()`, and `summarise()` : ces verbes utilisent le masquage de données (data masking). De cette facon, les variables dans des données peuvent être utilisées comme si elles étaient dans l'environnement. Plus besoin d'écrire 'df$var' mais simplement 'var' dans le verbe dplyr.

- `across()`, `relocate()`, `rename()`, `select()`, and `pull()` : ces verbes utilisent la sélection tidy et permettent de choisir facilement des variables en se basant sur leur position, leur nom ou leur type  (e.g. `starts_with("x")` or `is.numeric()`).

Ces verbes rendent l'exploration de données rapide et fluide mais ils peuvent poser des problèmes dans le cas où ils sont utilisés dans des boucles ou des fonctions.

Une fonction qui utilise le data masking peut notamment poser problème lorsqu'elle appelle le nom d'une variable dans un tableau à partir d'une variable de l'environnement sans taper explicitement la variable du tableau (des exemples précis sont donnés par la suite). Dans ce cas, on peut utiliser le double crochet `{{}}` ou le `.data[[]]` si la variable est une chaine de charactère. De facon général, il faut différencier explicitement les variables selon qu'elles sont dans le dataframe ou dans l'environnment.

La séléction tidy est un outil complémentaire qui facilite le travaille sur les colonnes d'un jeu de données.

La suite du document donnent quelques exemple d'utilisation de rlang.

# Examples d'utilisation de rlang

## Tidy evaluation à l'aide de `{{` et `.data`. 

L'utilisation de fonctions du tidyverse dans des fonctions personnelles peut parfois poser problème

```{r, message=FALSE}
library(tidyverse)
data(penguins, package = "palmerpenguins")
```

```{r}
## This works
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) + 
  geom_point() + 
  ggtitle("Variable = species")
```

```{r, error = TRUE}
## This doesn't
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = var)) + 
    geom_point() + 
    ggtitle(glue::glue("{var}"))
}
my_plot(species)
```

Le problème vient de l'évaluation de `var` dans l'appel à `my_plot()`: R cherche `species` dans l'environnement parent de la fonction plutôt que dans le contexte du data.frame `penguins`. 

On peut remédier au problème à l'aide de l'opérateur `{{` qui permet de remplacer `var` par `species` dans l'appel à `ggplot` via le mécanisme de `quosure`. 

```{r}
## This works
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = {{ var }})) + 
    geom_point()
}
my_plot(species)
```

À noter qu'on obtient l'équivalent de `{{ var }}` en combinant `enquo` (conversion en "quosure" = expression + environnement) et `!!` (évaluation sauce "tidy") :

```{r, results='hide'}
## This works
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = !!enquo(var))) + 
    geom_point()
}
my_plot(species)
```

Si on veut afficher le titre de façon programmatique, il faut `ensym()` (conversion en symbole de l'expression passée en argument à une fonction) pour qu'il soit reconnu comme une chaîne de caractères

```{r}
## This works
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = {{ var }})) + 
    geom_point() + 
    ggtitle(glue::glue("Variable = {ensym(var)}"))
}
my_plot(species)
```

Attention, dans cet example, l'argument de `my_plot()` est une expression. On ne peut donc pas itérer sur les colonnes catégorielles de `penguins` stockées dans un vecteur de `"character"`: ces dernières ne sont pas interprétées correctement...

```{r}
cat_vars <- names(penguins)[map_lgl(penguins, is.factor)] ## [1] "species" "island"  "sex" 
map(cat_vars, my_plot) %>% cowplot::plot_grid(plotlist = .)
```

Pour que `my_plot()` accepte des chaînes de caractères, il faut utiliser le pronom spécial `.data` pour préciser que la variable doit être cherchée dans le tableau `penguins`. 

```{r}
## This works
my_plot <- function(var) {
  ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = .data[[var]] )) + 
    geom_point() + 
    ggtitle(glue::glue("Variable = {var}"))
}
my_plot("species")
```


```{r}
map(cat_vars, my_plot) %>% cowplot::plot_grid(plotlist = .)
```

## Comparaisons entre `.env` et `.data`. 

Essayons de ne représenter qu'une partie du jeu de données, par exemple les manchots Adelie

```{r}
ggplot(penguins %>% filter(species == "Adelie"), 
       aes(x = bill_length_mm, y = bill_depth_mm, color = island)) + 
    geom_point() + 
    ggtitle("Penguins of species Adelie, colored by island")
```

On peut essayer de fonctionaliser ce graphique

```{r}
## This seems to works
my_plot <- function(species) {
  ggplot(penguins %>% filter(species == species), 
         aes(x = bill_length_mm, y = bill_depth_mm, color = island )) + 
    geom_point() + 
    ggtitle(glue::glue("Penguins of species {species}, colored by island"))
}
```

Mais ça ne marche pas...
```{r}
my_plot("Adelie")
```

Il faut être rigoureux et distinguer la _data variable_ `species` de la valeur de l'_argument_ `species`. On peut renommer l'argument en `.species` mais c'est désagréable. Une solution élégante consiste à utiliser le pronom `.env` pour distinguer les deux symboles. 

```{r}
## This works
my_plot <- function(species) {
  ggplot(penguins %>% filter(species == .env$species), 
         aes(x = bill_length_mm, y = bill_depth_mm, color = island )) + 
    geom_point() + 
    ggtitle(glue::glue("Penguins of species {species}, colored by island"))
}
```

```{r}
my_plot("Adelie")
```

On peut alors itérer sur les espèces de penguins
```{r}
unique(penguins$species) %>% map(my_plot) %>% cowplot::plot_grid(plotlist = .)
```

On peut évidemment combiner la sélection d'une espèce avec le coloriage par une variable catégorielle. 

```{r}
my_plot <- function(species, color) {
  ggplot(penguins %>% filter(species == .env$species), 
         aes(x = bill_length_mm, y = bill_depth_mm, color = .data[[color]])) + 
    geom_point() + 
    ggtitle(glue::glue("Penguins of species {species}, colored by {color}"))
}
my_plot("Adelie", "sex")
```

## Passage d'arguments par promesse versus par nom

Les versions `my_plot(var = species)` et `my_plot(var = "species")` diffèrent dans la nature de l'argument: une expression dans le premier cas, une chaîne de caractères dans le deuxième. La première version est plus souple. 

```{r}
my_plot_char <- function(x, y) {
  ggplot(penguins, 
         aes(x = .data[[x]], y = .data[[y]], color = species)) + 
    geom_point()
}
my_plot_char(x = "bill_length_mm", y = "bill_depth_mm")
```
```{r}
my_plot_expr <- function(x, y) {
  ggplot(penguins, 
         aes(x = {{x}}, y = {{y}}, color = species)) + 
    geom_point()
}
my_plot_expr(x = bill_length_mm, y = bill_depth_mm)
```
Contrairement à `my_plot_char()`, `my_plot_expr()` peut être utilisée avec des expressions, _i.e._ des transformations des variables de `penguins` calculées à la volée:

```{r}
my_plot_expr(x = bill_length_mm - bill_depth_mm, y = bill_length_mm + bill_depth_mm)
```

## Utiliser des chaînes de caractères dans fonctions du tidyverse

On peut avoir envie d'itérer sur des variables stockées dans vecteurs de type `character`. C'est facile avec `my_plot_char()` mais légèrement plus difficile avec `my_plot_expr()`

```{r}
var_x <- "bill_length_mm"
var_y <- "bill_depth_mm"
## Works fine
my_plot_char(var_x, var_y)
```
```{r error = TRUE}
## Does not work as intended
my_plot_expr(var_x, var_y)
```

On peut néanmoins s'en sortir à l'aide du pronom `.data` précédemment présenté

```{r error = TRUE}
## Works as intended
my_plot_expr(.data[[var_x]], .data[[var_y]])
```

Et itérer sur des tableaux

```{r}
cont_vars <- c("bill_length_mm", "bill_depth_mm", "flipper_length_mm", "body_mass_g")
df <- crossing(x = cont_vars, y = cont_vars) 
plot_list <- map2(.x = df$x, .y = df$y, ~ my_plot_expr(.data[[.x]], .data[[.y]]) + theme(legend.position = "none"))
cowplot::plot_grid(plotlist = plot_list)
```


## Utilisation de `:=`

